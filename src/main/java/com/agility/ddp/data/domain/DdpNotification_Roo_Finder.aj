// WARNING: DO NOT EDIT THIS FILE. THIS FILE IS MANAGED BY SPRING ROO.
// You may push code into the target .java compilation unit if you wish to edit any member(s).

package com.agility.ddp.data.domain;

import com.agility.ddp.data.domain.DdpAedRule;
import com.agility.ddp.data.domain.DdpExportRule;
import com.agility.ddp.data.domain.DdpNotification;
import com.agility.ddp.data.domain.DdpRuleDetail;
import java.util.Calendar;
import java.util.Set;
import javax.persistence.EntityManager;
import javax.persistence.TypedQuery;

privileged aspect DdpNotification_Roo_Finder {
    
    public static TypedQuery<DdpNotification> DdpNotification.findDdpNotificationsByDdpAedRules(Set<DdpAedRule> ddpAedRules) {
        if (ddpAedRules == null) throw new IllegalArgumentException("The ddpAedRules argument is required");
        EntityManager em = DdpNotification.entityManager();
        StringBuilder queryBuilder = new StringBuilder("SELECT o FROM DdpNotification AS o WHERE");
        for (int i = 0; i < ddpAedRules.size(); i++) {
            if (i > 0) queryBuilder.append(" AND");
            queryBuilder.append(" :ddpAedRules_item").append(i).append(" MEMBER OF o.ddpAedRules");
        }
        TypedQuery<DdpNotification> q = em.createQuery(queryBuilder.toString(), DdpNotification.class);
        int ddpAedRulesIndex = 0;
        for (DdpAedRule _ddpaedrule: ddpAedRules) {
            q.setParameter("ddpAedRules_item" + ddpAedRulesIndex++, _ddpaedrule);
        }
        return q;
    }
    
    public static TypedQuery<DdpNotification> DdpNotification.findDdpNotificationsByDdpExportRules(Set<DdpExportRule> ddpExportRules) {
        if (ddpExportRules == null) throw new IllegalArgumentException("The ddpExportRules argument is required");
        EntityManager em = DdpNotification.entityManager();
        StringBuilder queryBuilder = new StringBuilder("SELECT o FROM DdpNotification AS o WHERE");
        for (int i = 0; i < ddpExportRules.size(); i++) {
            if (i > 0) queryBuilder.append(" AND");
            queryBuilder.append(" :ddpExportRules_item").append(i).append(" MEMBER OF o.ddpExportRules");
        }
        TypedQuery<DdpNotification> q = em.createQuery(queryBuilder.toString(), DdpNotification.class);
        int ddpExportRulesIndex = 0;
        for (DdpExportRule _ddpexportrule: ddpExportRules) {
            q.setParameter("ddpExportRules_item" + ddpExportRulesIndex++, _ddpexportrule);
        }
        return q;
    }
    
    public static TypedQuery<DdpNotification> DdpNotification.findDdpNotificationsByDdpRuleDetails(Set<DdpRuleDetail> ddpRuleDetails) {
        if (ddpRuleDetails == null) throw new IllegalArgumentException("The ddpRuleDetails argument is required");
        EntityManager em = DdpNotification.entityManager();
        StringBuilder queryBuilder = new StringBuilder("SELECT o FROM DdpNotification AS o WHERE");
        for (int i = 0; i < ddpRuleDetails.size(); i++) {
            if (i > 0) queryBuilder.append(" AND");
            queryBuilder.append(" :ddpRuleDetails_item").append(i).append(" MEMBER OF o.ddpRuleDetails");
        }
        TypedQuery<DdpNotification> q = em.createQuery(queryBuilder.toString(), DdpNotification.class);
        int ddpRuleDetailsIndex = 0;
        for (DdpRuleDetail _ddpruledetail: ddpRuleDetails) {
            q.setParameter("ddpRuleDetails_item" + ddpRuleDetailsIndex++, _ddpruledetail);
        }
        return q;
    }
    
    public static TypedQuery<DdpNotification> DdpNotification.findDdpNotificationsByNotCreatedDateBetween(Calendar minNotCreatedDate, Calendar maxNotCreatedDate) {
        if (minNotCreatedDate == null) throw new IllegalArgumentException("The minNotCreatedDate argument is required");
        if (maxNotCreatedDate == null) throw new IllegalArgumentException("The maxNotCreatedDate argument is required");
        EntityManager em = DdpNotification.entityManager();
        TypedQuery<DdpNotification> q = em.createQuery("SELECT o FROM DdpNotification AS o WHERE o.notCreatedDate BETWEEN :minNotCreatedDate AND :maxNotCreatedDate", DdpNotification.class);
        q.setParameter("minNotCreatedDate", minNotCreatedDate);
        q.setParameter("maxNotCreatedDate", maxNotCreatedDate);
        return q;
    }
    
    public static TypedQuery<DdpNotification> DdpNotification.findDdpNotificationsByNotCreatedDateEquals(Calendar notCreatedDate) {
        if (notCreatedDate == null) throw new IllegalArgumentException("The notCreatedDate argument is required");
        EntityManager em = DdpNotification.entityManager();
        TypedQuery<DdpNotification> q = em.createQuery("SELECT o FROM DdpNotification AS o WHERE o.notCreatedDate = :notCreatedDate", DdpNotification.class);
        q.setParameter("notCreatedDate", notCreatedDate);
        return q;
    }
    
    public static TypedQuery<DdpNotification> DdpNotification.findDdpNotificationsByNotFailureEmailAddressEquals(String notFailureEmailAddress) {
        if (notFailureEmailAddress == null || notFailureEmailAddress.length() == 0) throw new IllegalArgumentException("The notFailureEmailAddress argument is required");
        EntityManager em = DdpNotification.entityManager();
        TypedQuery<DdpNotification> q = em.createQuery("SELECT o FROM DdpNotification AS o WHERE o.notFailureEmailAddress = :notFailureEmailAddress", DdpNotification.class);
        q.setParameter("notFailureEmailAddress", notFailureEmailAddress);
        return q;
    }
    
    public static TypedQuery<DdpNotification> DdpNotification.findDdpNotificationsByNotModifiedDateBetween(Calendar minNotModifiedDate, Calendar maxNotModifiedDate) {
        if (minNotModifiedDate == null) throw new IllegalArgumentException("The minNotModifiedDate argument is required");
        if (maxNotModifiedDate == null) throw new IllegalArgumentException("The maxNotModifiedDate argument is required");
        EntityManager em = DdpNotification.entityManager();
        TypedQuery<DdpNotification> q = em.createQuery("SELECT o FROM DdpNotification AS o WHERE o.notModifiedDate BETWEEN :minNotModifiedDate AND :maxNotModifiedDate", DdpNotification.class);
        q.setParameter("minNotModifiedDate", minNotModifiedDate);
        q.setParameter("maxNotModifiedDate", maxNotModifiedDate);
        return q;
    }
    
    public static TypedQuery<DdpNotification> DdpNotification.findDdpNotificationsByNotModifiedDateEquals(Calendar notModifiedDate) {
        if (notModifiedDate == null) throw new IllegalArgumentException("The notModifiedDate argument is required");
        EntityManager em = DdpNotification.entityManager();
        TypedQuery<DdpNotification> q = em.createQuery("SELECT o FROM DdpNotification AS o WHERE o.notModifiedDate = :notModifiedDate", DdpNotification.class);
        q.setParameter("notModifiedDate", notModifiedDate);
        return q;
    }
    
    public static TypedQuery<DdpNotification> DdpNotification.findDdpNotificationsByNotStatusEquals(Integer notStatus) {
        if (notStatus == null) throw new IllegalArgumentException("The notStatus argument is required");
        EntityManager em = DdpNotification.entityManager();
        TypedQuery<DdpNotification> q = em.createQuery("SELECT o FROM DdpNotification AS o WHERE o.notStatus = :notStatus", DdpNotification.class);
        q.setParameter("notStatus", notStatus);
        return q;
    }
    
    public static TypedQuery<DdpNotification> DdpNotification.findDdpNotificationsByNotSuccessEmailAddressEquals(String notSuccessEmailAddress) {
        if (notSuccessEmailAddress == null || notSuccessEmailAddress.length() == 0) throw new IllegalArgumentException("The notSuccessEmailAddress argument is required");
        EntityManager em = DdpNotification.entityManager();
        TypedQuery<DdpNotification> q = em.createQuery("SELECT o FROM DdpNotification AS o WHERE o.notSuccessEmailAddress = :notSuccessEmailAddress", DdpNotification.class);
        q.setParameter("notSuccessEmailAddress", notSuccessEmailAddress);
        return q;
    }
    
}
